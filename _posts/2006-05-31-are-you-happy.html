---
layout: post
title: Are You Happy?
categories: []
tags: []
status: publish
type: post
published: true
meta: {}
---
<p>I read a lot of feeds. A <em>lot</em> of feeds. In my hobby trend-spotting (it&#8217;s like a dorkier birdwatching), I read my feeds to monitor the zeitgeist to see what the real <a href="http://www.macdevcenter.com/pub/a/mac/2002/05/14/oreilly_wwdc_keynote.html">Alpha Geeks</a> are into. And the last year has had some interesting trends. For instance, dynamic languages like Python and Ruby are now firmly the new wave, although functional languages (Haskell, <span class="caps">OCAML</span>) and prototype languages (Io) seem to also be attracting interest. Web2.0 is a term bandied around casually, mocked, and even <a href="http://radar.oreilly.com/archives/2006/05/web_20_service_mark_controvers.html">litigated over</a> , but the concept seems to be here to stay. The most novel aspect I&#8217;ve seen about Web2.0 is that the Web has become a source of real tools many developers are using to manage their lives; as a holder of Sun stock much diminished in value, I guess I can at least take comfort in the fact that their adage &#8220;The network is the computer&#8221; seems to finally be coming true. Sure, it&#8217;s about 6 years later than predicted, but it&#8217;s happening.</p>


	<p>But most interesting to me is when the alpha geeks flock to ideas not directly related to coding frameworks, business plans or the like. For instance, six months ago it seemed like every serious hacker was devouring <a href="http://www.davidco.com/">Getting Things Done</a> and blogging about organizing their lives. And now the new obsession is <a href="http://web.ionsys.com/~remedy/FLOW%20%20.htm">Flow</a>. A conceptualiztion first coined in a book fifteen years ago, Flow is a term Mihaly Csiksczentmihalyi (<em>don&#8217;t ask me to pronounce that</em>) coined for that mental state where work is  stimulating but not frustrating, intention translates effortlessly into action, and happiness and productivity are intertwined. Csiksczentmihalyi teased out a description of Flow by looking at the mental states of people practicing Zen mindfulness or risking bodily harm in extreme sports like rock-climbing or surfing. But he could just as easily described the euphoric states of serious computer programming. Small wonder this  book has now been &#8220;discovered&#8221; by the alpha geeks, this fleeting feeling is what we find so addictive about programming in the first place.</p>


	<p><span style="float:right;display:block;padding:5px;"><img src="http://www.nimblecode.com/files/flow_channel.jpg" alt="" /></span> The basic concept of Flow is that certain tasks make us happy to do them because they exist within a narrow channel between fear and boredom, because they encourage us to improve our skills but do not overwhelm us with too many challenges at once (<em>for Donnie Darko fans, the goal of flow is to find the middle of the fear-love axis</em>). We developers are well-acquainted with that fear. It&#8217;s the fear that keeps you from refactoring that legacy system because you&#8217;re not sure what would break, the fear that keeps us using a clunky library because we can&#8217;t test changes, the fear that makes deploying the new version to the server nail-biting because it&#8217;s crammed full of changes that might take it down. In short, fear and specifically <em>fear of change</em> is a constant state of mind for too many programmers, but it doesn&#8217;t have to be. A state of happiness is possible if you can conquer the fear.</p>


	<p>Flow is the reason why some frameworks like Ruby on Rails are so appealing to programmers; it straddles that line between utter boredom (coding a web site in <span class="caps">PHP</span> like always) and high anxiety (having to master a complicated system like Cocoon just to print out &#8220;Hello World&#8221;). The key is allowing people to add capabilities (like authentication, tagging) as their skills grow, but not require everything to be planned up front. It conquers the fear of change, but hacking change into smaller steps. What makes a framework <em>good</em> (the same is true for languages, methodologies, testing, architectures) is how it destroys this anxiety.</p>


	<p>For most of my career, the basic question asked of developers was <strong>are you productive?</strong> Computer programmers are naturally obsessed with productivity. This is after all a field where good programmers can outperform bad coders by several orders of magnitude. and for years the industry has marketed to this by selling tools that promise leaps in productivity. The key to productivity was seen only through uses of higher-level toolsets/IDEs or APIs. This is a philosophy Cote has memorably termed <a href="http://www.redmonk.com/cote/archives/2006/05/oracle_develope.html">Right-Click Coding</a> because of all the right clicking and fiddling you have to do to get anywhere. This was seen as a development accelerator, because it enabled poor developers to do complicated things like enterprise integration and <span class="caps">GUI</span> development without needing to actually write code or learn details of how things work. But, I think that overall such tools have actually decreased developer productivity in several ways. Like a teacher teaching only to her worst students in class, the wizards and libraries stifle and frustrate more able programmers. And since they remove developers from using the underlying code, wizards only accelerate bloat and complexity in their underlying code bases.</p>


	<p>Worse of all, the fear was still out there. Indeed, like air conditioner output makes city streets hotter, they&#8217;ve made the situation worse. By piling away programming within massive APIs and single-purpose wizards, this approach has created a nightmare of complexity waiting to ambush more able developers. Now the question becomes <strong>are you compliant?</strong> Being savvy to the latest standards, libraries, or buzzwords is touted as the key. But the difficulties people have had using <span class="caps">SOAP</span> is but one example of how compliance doesn&#8217;t really help either.
Just mention &#8220;interop&#8221; to any <span class="caps">CTO</span> or high-level architect and you&#8217;ll see what I mean. The complexity (and the fear) are still there, standards compliance just blames the programmer when things go wrong.</p>


	<p>Instead, it&#8217;s time for a new question: <strong>are you happy?</strong> I think the growing interest in Flow and <span class="caps">GTD</span> and higher-level languages and test-driven development and agile project management reflects a sea change in attitude by the alpha geeks. Trying to find happiness through artificially increasing productivity is like putting the cart before the horse. The key point of Flow is not that productivity fights fear and creates happiness, but recognizing that creating happiness is what creates productivity. I think it&#8217;s about time, if we want to avoid the descent into compromises and disillusionment common in computer science. So, get in touch with your feelings when deciding about that design, language, system, api, etc. and ask yourself &#8220;am I happy doing this?&#8221; I think your instincts are a better guide than you know. Trust them. And don&#8217;t be afraid to be happy.</p>


	<p><strong>Update:</strong> I added some links to the original book as well as discussion in a <a href="http://www.nimblecode.com/articles/2006/06/01/short-takes-pdas-planet-argon-and-happiness">short take posting</a>. Happy reading!</p>
